// Alternative deployment using ethers.js (no Foundry required)
// Run: node deploy.js

const { ethers } = require('ethers');
const fs = require('fs');
const path = require('path');

// Configuration
const RPC_URL = 'https://base-sepolia.g.alchemy.com/v2/ViKdKqcr6Qz6WWzjWYYq2';
const USDC_ADDRESS = '0x036CbD53842c5426634e7929541eC2318f3dCF7e';
const PRIVATE_KEY = process.env.PRIVATE_KEY; // Set this before running

// ABI and Bytecode (simplified - will be generated by Foundry)
// For now, this is a placeholder showing the structure
const CONTRACT_ABI = [
  "constructor(address _paymentToken)",
  "function registerAgent(string metadataURI, uint256 tier) returns (bytes32 agentId)",
  "function verifyAgent(bytes32 agentId, uint256 score, bool passed, string reportURI)",
  "function updateReputation(bytes32 agentId, int256 delta)",
  "function getAgent(bytes32 agentId) view returns (tuple)",
  "event AgentRegistered(bytes32 indexed agentId, address indexed owner, string metadataURI, uint256 subscriptionExpiresAt)"
];

async function deploy() {
  if (!PRIVATE_KEY) {
    console.error('‚ùå Set PRIVATE_KEY environment variable');
    process.exit(1);
  }

  console.log('ü¶û Deploying VerifiedAgentRegistry...');
  
  // Connect to network
  const provider = new ethers.JsonRpcProvider(RPC_URL);
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider);
  
  console.log(`Deployer: ${wallet.address}`);
  
  // Check balance
  const balance = await provider.getBalance(wallet.address);
  console.log(`Balance: ${ethers.formatEther(balance)} ETH`);
  
  if (balance < ethers.parseEther('0.001')) {
    console.error('‚ùå Insufficient balance. Need at least 0.001 ETH');
    process.exit(1);
  }

  // Load contract bytecode
  // This requires the contract to be compiled first
  const bytecodePath = path.join(__dirname, 'out', 'VerifiedAgentRegistry.sol', 'VerifiedAgentRegistry.json');
  
  if (!fs.existsSync(bytecodePath)) {
    console.error('‚ùå Contract not compiled. Run: forge build');
    console.log('Or use the Foundry deployment script: ./deploy.sh');
    process.exit(1);
  }

  const contractJson = JSON.parse(fs.readFileSync(bytecodePath, 'utf8'));
  const bytecode = contractJson.bytecode.object;
  const abi = contractJson.abi;

  // Deploy
  const factory = new ethers.ContractFactory(abi, bytecode, wallet);
  
  console.log('Deploying contract...');
  const contract = await factory.deploy(USDC_ADDRESS);
  
  console.log(`Transaction hash: ${contract.deploymentTransaction().hash}`);
  
  await contract.waitForDeployment();
  
  const address = await contract.getAddress();
  
  console.log('');
  console.log('‚úÖ Deployment complete!');
  console.log(`Contract Address: ${address}`);
  console.log(`Network: Base Sepolia`);
  console.log(`USDC Token: ${USDC_ADDRESS}`);
  console.log('');
  console.log('Next steps:');
  console.log(`1. Update api/.env with: CONTRACT_ADDRESS=${address}`);
  console.log('2. Run: cd api && npm run dev');
  console.log('3. Test: curl http://localhost:3000/health');
  
  // Save deployment info
  const deploymentInfo = {
    network: 'base-sepolia',
    contractAddress: address,
    deployer: wallet.address,
    usdcAddress: USDC_ADDRESS,
    timestamp: new Date().toISOString(),
    transactionHash: contract.deploymentTransaction().hash
  };
  
  fs.writeFileSync(
    path.join(__dirname, 'deployment.json'),
    JSON.stringify(deploymentInfo, null, 2)
  );
  
  console.log('Deployment info saved to: contracts/deployment.json');
}

deploy().catch(console.error);
